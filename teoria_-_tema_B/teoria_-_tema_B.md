**ОГЛАВЛЕНИЕ** 

[РАБОТА СО СТРОКАМИ .......................................................................................... 4 ](#_page1_x54.00_y56.92)[Функции и методы строк ......................................................................................... 4 ](#_page1_x54.00_y84.92)[Форматирование строк с помощью метода format ............................................... 8 ](#_page5_x54.00_y684.92)[Текстовые файлы .................................................................................................... 11 ](#_page8_x54.00_y143.92)

**РАБОТА СО СТРОКАМИ Функции и методы строк** 

Строки  в  Python  задаются  с  использованием  одинарных  или  двойных кавычек, при этом важно использовать один и то же тип кавычек в начале и конце строки.  

Но  иногда  возникает  необходимость  использования  в  строке  символа «одинарная кавычка» или «двойная кавычка». Здесь и кроется причина двойной возможности задания строк. Так, если есть необходимость использовать символ одинарной кавычки (') в тексте, то для обозначения строки будем использовать двойные кавычки ("), и наоборот. Однако возможен и сценарий, когда в тексте нам может понадобиться и та, и та разновидность кавычек. В такой ситуации нам поможет  механизм  экранирования  символов,  для  чего  используется  символ «обратный слеш» (\).  

Внутри строки два символа (\' или \") будут восприняты интерпретатором языка как один текстовый символ и при этом не будут являться управляющими, т.е. не будут обозначать начало или конец строки. 

Также экранирование символов используется для задания управляющих символов, которые нельзя внести с клавиатуры. 



|\' |Одинарная кавычка, апостроф  |
| - | - |
|\" |Двойная кавычка |
|\\ |Обратный слеш |
|\n |Перенос строки |
|\t |Табуляция |
Если  перед  открывающей  кавычкой  у  строки  поставить  символ  'r',  то строка станет «сырой» (raw string), т.е. будет отключено экранирование. 

Также  существует  возможность  использования  тройных  кавычек  для удобного  задания  многострочных  строк  (нет  необходимости  использования символа переноса строки). 

Важным для строкового типа является понятие кодировки символов, по умолчанию Python хранит строки в кодировке UTF-8.  

1. str1 = "Строка задается в двойных кавычках \"" ![](Aspose.Words.65cdd225-2279-4a1a-bc25-5df195cf311c.001.png)
1. str2 = 'или в одинарных \'' 
3. str3 = "Для экранирования используется символ \\" ![](Aspose.Words.65cdd225-2279-4a1a-bc25-5df195cf311c.002.png)
3. str4 = """Возможно использование 
3. многострочных строк""" 
3. str5 = "В этой строке будет табуляция\tи\nперенос строки" 
3. str6 = r"А в этой строке не будет табуляции\tи\nпереноса строки" 
3. print(str1, str2, str3, str4, str5, str6) 

\>>> Строка задается в двойных кавычках " или в одинарных ' Для экранирования используется символ \ Возможно использование 

многострочных строк В этой строке будет табуляция и 

перенос строки А в этой строке не будет табуляции\tи\nпереноса строки 

Язык  Python  предоставляет  обширный  спсиок  функций  и  методов  для всевозможных операций со строками. 

Обозначения: str1, str2, str3 – строки; k, start, end, step – целые числа.  



|str3 = str1 + str2  |*Конкатенация*.  str3 – объединение  двух строк |
| - | :- |
|str3 = str1 \* k |*Дублирование*. str3  состоит  из  символов строкиstr1, повторяющихся k раз |
|str1[k] |*Индексация*. Получение символа по индексу k из строки |
|len(str1)  |*Длина.* Возвращает длину строки  |
|<p>str3 = </p><p>` `str1[start:end:step] </p>|*Срезы.* str3 будет содержать все символы из str1  с  индексами  со start  до end  (не включая его) с шагом step. Можно опускать значения  аргументы,  тогда  по  умолчанию: start = 0, end = len(str1), step = 1. Можно  указать  отрицательный  шаг,  тогда обход с конца в начало.* |


1. str1 = "abc" ![](Aspose.Words.65cdd225-2279-4a1a-bc25-5df195cf311c.003.png)
1. str2 = "123" 
3. str3 = (str1 + str2) \* 3 ![](Aspose.Words.65cdd225-2279-4a1a-bc25-5df195cf311c.004.png)
3. print(str3) 

\>>> abc123abc123abc123 

5. len(str3) 

\>>> 18 

6. str4 = str3[5:18:6] 
6. print(str4) 

\>>> 333 

В  таблице  представлены  наиболее  используемые  методы, применимые к строкам. Обозначения: str1, str2, str3 – строки; char1 – символ; k, start, end, step – целые числа; list1 – список.  



|str1.find(str2 [, start, [end]]) str1.index(str2 [, start, [end]]) |*Поиск подстроки*. Поиск str2 в строке str1 в интервале между индексами со start и до end (эти два параметра не обязательны). Возвращают индекс первого вхождения или при отсутствии (-1 для функции find или ошибку для функции index) |
| :- | :- |
|str1.rfind(str2 [, start, [end]]) str1.rindex(str2 [, start, [end]]) |*Поиск подстроки.* Аналогично двум предыдущим функциям, не возвращают индекс последнего вхождения |
|str1.count(str2 [, start, [end]]) |<p>*Количество вхождений.* Возвращает количество непересекающихся вхождений подстроки str2 в строку str1 (start и end </p><p>- необязательные параметры, границы диапазона поиска)  </p>|
|str2 in str1 str1.startswith(str2) str1.endswith(str2) |*Проверка вхождения.* Возвращает true или false в зависимости от того, содержит ли строка str1 подстроку str2 / начинается / заканчивается ли строка str1 подстрокой str2 |
|str1.replace(str2, str3 [, k]) |*Замена.* В строке str1 заменяются вхождения подстроки str2 на str3 (при указании необязательного параметра count замена осуществляется указанное количество раз) |
|list1 = str1.split(str2) |*Разбиение строки.* Функция возвращает список подстрок, вырезанных из строки str1, используя разделитель str2 (разделитель можно не указывать – по умолчанию, пробел)  |
|<p>str2 = </p><p>str1.join(list1)  </p>|*Объединение строк.* Объединение элементов списка list1 в строку, используя в качестве разделителя str1 |
|str1.isdigit() str1.isalpha() str1.isalnum() str1.isspace() |*Проверка символов.* Возвращает true или false в зависимости от того, состоит ли строка полностью из цифр / из букв / из цифр или букв / строка из неотображаемых символов (пробел, табуляция, перенос строки) |
|str1.islower() str1.isupper() str1.istitle() |*Проверка регистра.* Возвращает true или false в зависимости от того, состоит ли строка полностью из символов в нижнем / верхнем регистре / начинается с заглавной буквы |
|str2 = str1.upper() str2 = str1.lower() str2 = str1.capitalize() |*Изменение регистра.* Преобразование строки str1 к верхнему / нижнему регистру / первого символа к верхнему регистру, остальных к нижнему |
|ord(char1) chr(k) |*ASCII.* Получение кода ASCII по символу char1 / преобразование кода k ASCII в символ  |
|<p>str1.center(k [, char1]) str1.ljust(k [, char1]) str1.rjust(k [, </p><p>char1]) </p>|*Форматирование для вывода.* Возвращает выровненную строку str1 (по центру / левому краю / правому краю), дополняя по нужным краям символами char1 (пробел по умолчанию) до длины строки k |

|||
| :- | :- |
|str2 = str1.lstrip([char1]) str2 = str1.rstrip([char1])  str2 = str1.strip([char1]) |*Удаление символов.* Удаление символов char1 (по умолчанию пробелы) в начале строки / в конце строки / в начале и в конце строки |


1. str1 = "abcjh ikabcll abbbgabcj" ![](Aspose.Words.65cdd225-2279-4a1a-bc25-5df195cf311c.005.png)
1. "abc" in str1 # определение вхождения 

\>>> True 

3. str1.rfind("abc") # индекс последнего вхождения >>> 19 
3. str1.count("abc") # количество вхождений 

\>>> 3 

5. str1.replace("abc", "ABC") # замена 

\>>> 'ABCjh ikABCll abbbgABCj' 

6. list1 = str1.split() # разбиение по пробелу 
6. print(list1) 

\>>> ['abcjh', 'ikabcll', 'abbbgabcj'] 

8. str2 = str2.join(list1) # объединение  
8. print(str2) 

\>>> abcjh123ikabcll123abbbgabcj 

**Форматирование строк с помощью метода format** 

Довольно  часто  возникает  необходимость  подстановки  в  разные  части строки данные, которые в текущий момент неизвестны, а будут определены во время работы программы.  Такую подстановку можно выполнить с помощью метода формата.  



|Str2 = str1.format([args]) |*Форматирование.* Строка str1 (шаблон) будет преобразована с использованием аргументов, передаваемых в метод |
| :- | :- |
Существует три варианта подстановки: 

- без указания индексов; 
- с указанием индексов (в том числе возможны повторы); 
- с использованием именованных параметров. 
1. name = "Ivan" ![](Aspose.Words.65cdd225-2279-4a1a-bc25-5df195cf311c.006.png)
1. surname = "Ivanov" 
1. age = 20 
1. # без указания индексов 
1. "student {} {}, {} years old".format(surname, name, age) 

\>>> 'student Ivanov Ivan, 20 years old' 

6. # подстановка параметров по индексу 
6. "student {1} {0}, [{1} {2}.]".format(name, surname, name[0]) 

\>>> 'student Ivanov Ivan, [Ivanov I.]' 

8. # именованные параметры 
8. "student {surname} {name}".format(name="Ivan", surname="Ivanov") 

\>>> 'student Ivanov Ivan'** 

Однако  возможности  метода  гораздо  шире,  помимо  подстановки параметров,  мы  можем  определить  форму  вывода  используя  различные модификаторы: 



|{:[fill][align] [width]} |<p>*Выравнивание текста*.  </p><p>width = количество символов в строке; </p>|
| :- | - |

||<p>align = "^"- выравнивание  по  центру,  ">" - по правому краю, "<” - по левому краю; </p><p>fill = символ заполнитель до нужного количества символов  (по  умолчанию  пробел)  количество символов и символ подстановки </p>|
| :- | :- |
|{:[sign] [.precision] [type]} |<p>*Форматирование вещественных чисел.* </p><p>sign = "+" -  знак  должен  быть  использован  для всех чисел, "-" - только для отрицательных, " " - для положительных ставить пробел; </p><p>precision = точность; </p><p>type = "d" - десятичное число, "o" - в восьмеричной системе, "x" и "X" - в шестнадцатеричной системе, </p><p>- f" - с плавающей точкой, "e" и "E" - с плавающей точкой с экспонентой, "%" - число умножается на 100, отображается число с плавающей точкой, а за ним знак % </p>|
Данные  шаблоны  можно  комбинировать,  а  перед  символом  двоеточия указывается  индекс  для  нумерованных  параметров  или  название  для именованных параметров.  

1. str1 = "string" ![](Aspose.Words.65cdd225-2279-4a1a-bc25-5df195cf311c.007.png)
1. "{:>30}".format(str1) 

\>>> '                        string' 

3. "{:\*^30}".format(str1) 

\>>> '\*\*\*\*\*\*\*\*\*\*\*\*string\*\*\*\*\*\*\*\*\*\*\*\*' 

4. pi = 3.141592653589793 
4. "{:+.5}".format(pi) 

\>>> '+3.1416' 

6. "{: .5E}".format(pi) >>> ' 3.14159E+00' 
7. "int: {0:d}; hex: {0:#X}; oct: {0:#o}; bin: ![](Aspose.Words.65cdd225-2279-4a1a-bc25-5df195cf311c.008.png){0:#b}".format(42) 

\>>> 'int: 42; hex: 0X2A; oct: 0o52; bin: 0b101010' **Текстовые файлы** 

Язык программирования Python поддерживает различные типы файлах, которые  условно  можно  разделить  на  текстовые  (информация  сохранена  в текстовом виде) и бинарные (изображения, аудио, видео и т.д.). Для бинарных файлов работа сними  будут сильно отличаться от типа файла.  Работа же с текстовыми  файлами  в  общем  случае  стандартна.  Для  хранения  текстовых данных будем использовать файлы с расширением txt, но также это могут быть, например, csv или html файлы. 

Существует  четыре  операции  с  текстовыми  файлами,  которые  следует выполнять в определенной последовательности: открытие файла, затем чтение из файла или запись в файл и в конце обязательное закрытие файла. 



|f = open(filename, mode [, encoding]) |<p>` `*Открытие файла.* Функция возвращает файловый </p><p>объект, который ассоциируется с файлом, и через него в дальнейшем происходит работа. </p><p>filename  =  строка,  путь  к  файлу:  абсолютный или  относительный  (тогда  поиск  файла  будет осуществляться в той же директории, в которой лежит Python-программа); </p><p>mode = режим открытия файла:  </p><p>"r"  –  на  чтение  (если  файла  не  существует  – ошибка),  </p><p>- w" – на запись (всегда создается новый файл, если он  уже  существовал,  то  все  старые  данные стираются),  </p><p>- a" – на дозапись (если файл не существует, то он создается,  а  если  существует,  то  запись осуществляется в конец файла),  </p><p>- b" – для работы с бинарными файлами. </p><p>Режимы можно комбинировать: "rw" – на чтение и  запись,  "rb"  или  "wb"  –  чтение  или  запись бинарного файла. </p>|
| :- | - |

||encoding = кодировка (например, "utf -8") |
| :- | - |
|text = f.read(k) |*Чтение  из  файла.*  Из файла  будет прочитано k байт и записано в строку text (если k не указано, будет прочитан весь файл) |
|line = f.readline()|<p>` `*Чтение строки.* Из файла будет прочитана одна </p><p>строка и записана в line </p>|
|lines  = f.readlines() |<p>` `*Построчное  чтение.*  Функция  вернет  список </p><p>строк из файла. </p>|
|f.write(text) |*Запись в файл.* В файл будет записана строка text, функция возвращает количество записанных байт |
|f.writelines(list) |*Построчная  запись.*  В  файл  будут  записаны строки из списка lines |
|f.close() |*Закрытие файла.* Обязательная для выполнения функция,  освобождает  все  связанные  с  файлом используемые ресурсы |
При открытии файла или в процессе работы с ним мы можем столкнуться с различными исключительными ситуациями (например, к файлу нет доступа). В  этом  случае  программа  выдаст  ошибку,  ее  выполнение  завершится, соответственно не произойдет закрытия файла. Для решения таких ситуаций правильным является обработка исключений. 

Также  возможно  использовании  конструкции  with  с  автоматическим закрытием файлов. 



|with open(file, mode) as f:     инструкции|Для открытого файла с указанными модификаторами доступа создается файловая переменная f, после всех инструкций файл закрывается. |
| :- | - |
\1.  filename = "file.txt" ![](Aspose.Words.65cdd225-2279-4a1a-bc25-5df195cf311c.009.png)2. 

3. # чтение из файла (в одну строку) 
3. with open(filename, "r") as fh: 
3. data = fh.read() 
3. print(data) 

\7. 

8. # чтение из файла (в список) 
9. with open(filename, "r") as fh: ![](Aspose.Words.65cdd225-2279-4a1a-bc25-5df195cf311c.010.png)
9. data = fh.readlines() 
9. print(data) 
 
9. # чтение из файла (построчно) 
9. with open(filename, "r") as fh: 
9. for line in fh: 
9. print(line) 
13 
